// prisma/schema.prisma
generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
  schemas  = ["public"]
}

model User {
  id             String   @id @default(uuid())          
  email          String   @unique @db.Citext
  email_verified Boolean  @default(false)
  created_at     DateTime @default(now()) @db.Timestamptz(6)
  last_login     DateTime? @db.Timestamptz(6)

  consent_privacy         Boolean     @default(false)
  consent_privacy_at      DateTime?
  consent_privacy_version Int?

  sessions       Session[]

  lifestyleSurvey LifestyleSurvey?   
  chatMembers ChatMember[]
  messages    Message[]

  /** 내가 요청한 매칭 */
  requestedMatches RoommateMatch[] @relation("RequesterMatches")

  /** 내가 후보로 포함된 매칭 */
  candidateMatches RoommateMatch[] @relation("CandidateMatches")

  likesGiven    UserLike[] @relation("UserLikesFrom")
  likesReceived UserLike[] @relation("UserLikesTo")
  
  @@schema("public")


  
}

model Session {
  id             String   @id @default(uuid())          
  user_id        String                                  
  session_token  String   @unique
  created_at     DateTime @default(now()) @db.Timestamptz(6)
  expires_at     DateTime @db.Timestamptz(6)
  ip             String?
  user_agent     String?
  user           User     @relation(fields: [user_id], references: [id], onDelete: Cascade)
  @@index([user_id, expires_at], map: "idx_sessions_user_expires")

  @@schema("public")

}


model VerificationCode {
  id           String    @id @default(uuid())
  email        String    @db.VarChar(255)
  code_hash    String    @db.VarChar(255)
  expires_at   DateTime
  consumed_at  DateTime?
  attempts     Int       @default(0)
  created_at   DateTime  @default(now())

  @@index([email, expires_at])
  @@schema("public")
  @@map("VerificationCode")
}

enum Gender {
  MALE
  FEMALE

  @@schema("public")
}

enum ShowerFreq {
  ONCE
  TWICE
  TWO_DAYS
  RARE

  @@schema("public")
}

enum CleaningFreq {
  ONCE
  TWICE
  TWO_DAYS
  RARE

  @@schema("public")
}

enum ActivityLevel {
  SMOKER
  NON_SMOKER

  @@schema("public")
}

enum OutgoingFreq {
  EVERY_WEEK
  TWO_WEEKS
  WEEKENDS
  VACATION

  @@schema("public")
}

enum MealPlace {
  DORM
  OUTSIDE

  @@schema("public")
}

enum GamingTime {
  NONE
  ONE_MINUS
  ONE_TO_THREE
  THREE_PLUS

  @@schema("public")
}

enum DrinkFreq {
  NONE
  RARE
  ONE_TWO
  THREE_PLUS

  @@schema("public")
}

enum EI {
  E
  I

  @@schema("public")
}

enum NS {
  N
  S

  @@schema("public")
}

enum TF {
  T
  F

  @@schema("public")
}

enum JP {
  J
  P

  @@schema("public")
}


model LifestyleSurvey {
  id              String   @id @default(uuid())
  userId          String   @unique
  user            User     @relation(fields: [userId], references: [id])

  age             Int
  department      String
  gender          Gender

  // MBTI 분리
  mbti1           EI
  mbti2           NS
  mbti3           TF
  mbti4           JP

  // minutes
  wakeTimeMinutes Int
  sleepTimeMinutes Int

  showerFreq      ShowerFreq
  cleaningFreq    CleaningFreq

  activityLevel   ActivityLevel

  roomTraits      String[]    // 그대로 OK
  coldSensitivity Boolean
  hotSensitivity  Boolean

  outgoingFreq    OutgoingFreq
  mealPlace       MealPlace
  mealNote        String      @db.VarChar(15)

  gamingTime      GamingTime
  drinkFreq       DrinkFreq

  homeStyle       String[]
  hobbies         String[]

  roommateWish    String      @db.VarChar(150)
  selfTags        String[]

  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt

  @@schema("public")
}


model ChatRoom {
  id          String        @id @default(uuid())
  created_at  DateTime      @default(now()) @db.Timestamptz(6)

  members     ChatMember[]
  messages    Message[]
  @@schema("public")
}

model ChatMember {
  id          String        @id @default(uuid())
  room_id     String
  user_id     String

  // 나중에 "읽음 처리" 혹은 "마지막 읽은 메시지 ID" 넣을 수 있음
  last_read_message_id String?

  room        ChatRoom      @relation(fields: [room_id], references: [id], onDelete: Cascade)
  user        User          @relation(fields: [user_id], references: [id], onDelete: Cascade)

  @@unique([room_id, user_id]) // 같은 방에 같은 유저 중복 방지
  @@schema("public")
}

model Message {
  id          String        @id @default(uuid())
  room_id     String
  sender_id   String
  content     String
  created_at  DateTime      @default(now()) @db.Timestamptz(6)

  room        ChatRoom      @relation(fields: [room_id], references: [id], onDelete: Cascade)
  sender      User          @relation(fields: [sender_id], references: [id])

  @@schema("public")
}


enum MatchStatus {
  PENDING    // 요청을 보냈고, 상대 응답 대기
  ACCEPTED   // 요청자가 수락
  REJECTED   // 요청자가 거절
  EXPIRED    // 기간 만료
  CONNECTED  // 채팅방 생성됨

  @@schema("public")
}

model RoommateMatch {
  id             String   @id @default(uuid())

  /** 매칭 요청자 */
  requesterId    String
  requester      User     @relation("RequesterMatches", fields: [requesterId], references: [id])

  /** 매칭 대상자 */
  candidateId    String
  candidate      User     @relation("CandidateMatches", fields: [candidateId], references: [id])

  /** 점수 관련 */
  baseScore      Float    // 0~100 (라이프스타일 점수)
  finalScore     Float    // multiplier + bonus 적용 후
  hobbyBonus     Float

  /** 매칭 상태 */
  status         MatchStatus

  /** 매칭 그룹화 ID */
  matchBatchId String

  /** 메타 정보 */
  createdAt      DateTime @default(now())
  expiresAt      DateTime?

  @@unique([requesterId, candidateId])
  @@index([requesterId])
  @@index([candidateId])

  @@schema("public")
}

model UserLike {
  id        String   @id @default(uuid())

  fromUserId String
  toUserId   String

  /** 찜한 사람 */
  fromUser User @relation("UserLikesFrom", fields: [fromUserId], references: [id])

  /** 찜 당한 사람 */
  toUser   User @relation("UserLikesTo", fields: [toUserId], references: [id])

  createdAt DateTime @default(now())

  /** 같은 사람이 같은 사람을 두 번 찜하지 못하게하는 중복 비허용을 위한 유니크 제약 조건 */
  @@unique([fromUserId, toUserId])

  /** index는 이 컬럼 기준으로 조회가 자주 일어날 것임을 명시 => 인덱스 있으면 조회 속도가 빨라짐 */
  @@index([fromUserId])
  @@index([toUserId])

  @@schema("public")
}
